#include "xil_io.h"
#include "xparameters.h"
#include <time.h>
#include <stdlib.h>
#include <stdbool.h>

// Define the base addresses of AXI slaves
//-------------------Actual Addresses for each Module------------
//#define AUDIO_BASE_ADDR  0x44a00000
//#define PERI_BASE_ADDR  0x44a10000
//#define VGA_SLAVE_ADDR   0x44a20000

//-------------------Simulating through GPIO ports------------
#define PUSH_BUTTON_BASE_ADDR  0x44a00000
#define LED_BASE_ADDR  0x40010000
#define RGB_LED_ADDR   0x40010008
#define SWITCHES_ADDR   0x40000008
#define PERI_ADDR      0x40030000
#define NUM_NOTES      0x40020000

#define HOME_SCREEN      0x0
#define SPACE      0x20


unsigned int get_random_U32_number(u32 *state) {
    u32 Number = *state;
    Number ^= Number << 13;
    Number ^= Number >> 17;
    Number ^= Number << 5;
    *state = Number;
    return Number;
}

int main() {
    u32 mode,result;
    u32 chord,LEDrep;
    int counter=0;
    int numNotes;
    u32 state_var;  // Declare a valid variable to hold the state
    u32 *state = &state_var;  // Initialize pointer to the address of state_var
    u32 initial_input;
    //srand(time(NULL));
    while(1){
    	result = Xil_In32(PERI_ADDR);
    	initial_input = Xil_In32(SWITCHES_ADDR)&0x3;
    	if (counter==0){
        	*state = result;
        	counter++;
    	}

    	mode = result & 0xF;
    	if (mode == 1)
    	{
    		//currently in homescreen
            //led[15]: Homescreen
    		Xil_Out32(RGB_LED_ADDR, 0x1);
    	}
        //switch[15] on
    	else if (mode == 2)
    	{
            //Xil_Out32(RGB_LED_ADDR, 0x20000);
    		numNotes = get_random_U32_number(state)%3 +1;
            //numNotes = Xil_In32(NUM_NOTES);
            //how many notes are randomly generated shown through led[1:0]
            //Xil_Out32(LED_BASE_ADDR, numNotes);
    		u32 *randNoteArray = malloc(numNotes * sizeof(u32));
    		u32 *UserInputs = malloc(numNotes * sizeof(u32));
    		int matches=0;
    		u32 AllMatch;
    		//sub with space ascii keyboard
    	    if (Xil_In32(SWITCHES_ADDR)&0x4) {
    	        LEDrep |= (1 << 15);  // Set LED[15]
    	    } else {
    	        LEDrep &= ~(1 << 15); // Clear LED[15] when button is not pressed
    	    }
            //show what notes are generated through
            //note 1: LED [3:2]
            //note 2: LED [5:4]
            //note 3: LED [7:6]
            for (int i=0;i<numNotes;i++){
    			randNoteArray[i]=get_random_U32_number(state)%4;
    			if (i!=0){
    				for(int j=0;j<i;j++){
    					while (randNoteArray[i] == randNoteArray[j]){
    						randNoteArray[i]=get_random_U32_number(state)%4;
    					}
    				}
    			}
    		}
    		//randNoteArray[0]=3;
            if (numNotes==1){
    			chord = (randNoteArray[0]<<2)+numNotes;
    			LEDrep=chord;
    			Xil_Out32(LED_BASE_ADDR, LEDrep);

    		}
    		else if (numNotes==2){
    			chord = (randNoteArray[0]<<2)+(randNoteArray[1]<<4)+numNotes;
    			LEDrep=chord;
    			Xil_Out32(LED_BASE_ADDR, LEDrep);
    		}
    		else{
    			chord = (randNoteArray[0]<<2)+(randNoteArray[1]<<4)+(randNoteArray[2]<<6)+numNotes;
    			LEDrep=chord;
    			Xil_Out32(LED_BASE_ADDR, LEDrep);
    		}


    		//0-11 +28
//    		//concatenate the chord for outputting the chord to the audio port
//    		while (Xil_In32(PUSH_BUTTON_BASE_ADDR)){
//    			Xil_Out32(LED_BASE_ADDR,chord);
//    		}
    		//if randomly generated note is just 1; user only need to input 1 input
            //only input data using switches[1:0]
    		//LEDrep=(UserInputs[0]<<8)|(UserInputs[1]<<10)|(UserInputs[2]<<12)|chord;
    		//Xil_Out32(LED_BASE_ADDR, LEDrep);
//            for (int i = 0; i < numNotes; i++) {
//                u32 newInput;
//                do {
//                    newInput = Xil_In32(SWITCHES_ADDR) & 0x3;  // Read switch value
//                } while ((i > 0 && newInput == UserInputs[i - 1])||(i==0 && newInput==initial_input));  // Ensure it's different
//                UserInputs[i] = newInput;  // Store valid input
//                LEDrep=(UserInputs[i]<<(8+i))|LEDrep;
//                Xil_Out32(LED_BASE_ADDR, LEDrep);
//            }
            if (numNotes == 1) {
                // Wait for user input change
                do {
                    UserInputs[0] = Xil_In32(SWITCHES_ADDR) & 0x3;
                } while (UserInputs[0] == initial_input); // Ensure input is different

                LEDrep = (UserInputs[0] << 8) | chord;
                Xil_Out32(LED_BASE_ADDR, LEDrep);
            }

            // If numNotes == 2, we must wait for two separate inputs
            if (numNotes == 2) {
                // Wait for first input
                do {
                    UserInputs[0] = Xil_In32(SWITCHES_ADDR) & 0x3;
                } while (UserInputs[0] == initial_input);

                // Show first input
                LEDrep = (UserInputs[0] << 8) | chord;
                Xil_Out32(LED_BASE_ADDR, LEDrep);

                // Wait for second input
                do {
                    UserInputs[1] = Xil_In32(SWITCHES_ADDR) & 0x3;
                } while (UserInputs[1] == UserInputs[0]); // Ensure different inputs

                // Show both inputs
                LEDrep = (UserInputs[0] << 8) | (UserInputs[1] << 10) | chord;
                Xil_Out32(LED_BASE_ADDR, LEDrep);
            }

            // If numNotes == 3, we must wait for three separate inputs
            if (numNotes == 3) {
                // Wait for first input
                do {
                    UserInputs[0] = Xil_In32(SWITCHES_ADDR) & 0x3;
                } while (UserInputs[0] == initial_input);

                // Show first input
                LEDrep = (UserInputs[0] << 8) | chord;
                Xil_Out32(LED_BASE_ADDR, LEDrep);

                // Wait for second input
                do {
                    UserInputs[1] = Xil_In32(SWITCHES_ADDR) & 0x3;
                } while (UserInputs[1] == UserInputs[0]); // Ensure different inputs

                // Show first two inputs
                LEDrep = (UserInputs[0] << 8) | (UserInputs[1] << 10) | chord;
                Xil_Out32(LED_BASE_ADDR, LEDrep);

                // Wait for third input
                do {
                    UserInputs[2] = Xil_In32(SWITCHES_ADDR) & 0x3;
                } while (UserInputs[2] == UserInputs[0] || UserInputs[2] == UserInputs[1]);

                // Show all three inputs
                LEDrep = (UserInputs[0] << 8) | (UserInputs[1] << 10) | (UserInputs[2] << 12) | chord;
                Xil_Out32(LED_BASE_ADDR, LEDrep);
            }

    		for (int x = 0; x < numNotes; x++) {
    		    for (int y = 0; y < numNotes; y++) {
    		        if (UserInputs[x] == randNoteArray[y]) {
    		            matches++;
    		            break;
    		        }
    		    }
    		}
////
    		AllMatch = (matches==numNotes)?1:0;  // True if all match
        //on the LED, userInputs:
        //userInput[0]: LED[9:8]
        //[1]: LED[11:10]
        //[2]:led[13:12]
        //Match:led[14]
    		LEDrep = LEDrep|(AllMatch<<14);
    		Xil_Out32(LED_BASE_ADDR, LEDrep);
  //    else should not do anything; if was just added to guarantee the first input
//      by the user is read
//    	else
//    	{
//
//    	}
		}
		else if(mode == 3){
			Xil_Out32(RGB_LED_ADDR, 0x3);
			//u32 referenceNote;
			//switches [1:0]
			u32 UserSang;
			u32 referenceNote=Xil_In32(NUM_NOTES)&0x3;
			if (Xil_In32(SWITCHES_ADDR)){
				//switches [3:2]
				UserSang=Xil_In32(SWITCHES_ADDR)&0x3;
			}
			//u32 referenceNote=freePlayInput& 0x11111110000;
			//userSang=Xil_In32(AUDIO_BASE_ADDR);
			u32 package;
			u32 Match_freePlay;
			if (UserSang){
				if(referenceNote==UserSang){
					Match_freePlay =1;
				}
				else{
					Match_freePlay =0;
				}
			}
			//led:
			//led[0]:match
			//led[2:1]: referenceNote
			//led[4:3]: userSang
			package = (UserSang<<4)+(referenceNote<<2)+Match_freePlay;
			Xil_Out32(LED_BASE_ADDR, package);
		}
    }
    return 0;
}
